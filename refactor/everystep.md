下面给出一份 **“AI-驱动重构脚本”**——把上一份总体方案拆成 6 个阶段、28 个最小任务（可根据项目规模再细化）。
每个任务都配好 ***精准、最小化的示例指令***（⚠️ 都带有“**只做 X，不做其他修改**”的限制语），可直接贴给 AI 使用。
执行顺序建议严格从上到下；完成一个任务并验证通过后，再进入下一项。

---

## 📦 第 0 阶段 — 安全网与基线

> 目标：确保后续任何改动都可随时回滚、对比、测试。

| #   | 任务                                            | 给 AI 的最小指令示例                                                    |
| --- | --------------------------------------------- | --------------------------------------------------------------- |
| 0-1 | 生成 `.gitignore`（针对 Python / venv / IDE 等常见目录） | **“请生成一份面向 Python 项目的 `.gitignore` 内容，只输出文件内容，不做其他说明。”**        |
| 0-2 | 冻结依赖列表                                        | **“根据 `pip freeze` 输出，帮我生成 `requirements.txt`，只列出包名和版本，不加解释。”** |
| 0-3 | 创建空测试骨架                                       | **“请创建项目根目录下 `tests/__init__.py` 文件，文件内容保持空白，不做其它改动。”**         |

---

## 🔍 第 1 阶段 — 现状扫描

> 目标：让 AI 仅帮助**观察**，不动代码。

| #   | 任务         | 给 AI 的最小指令示例                                                                               |
| --- | ---------- | ------------------------------------------------------------------------------------------ |
| 1-1 | 列出文件清单     | **“下面是当前项目的文件列表（粘贴树状结构）——请只按文件名罗列出：①每个 `.py` 文件里定义的顶层类/函数；②该文件 import 的本地模块。不要提出任何重构建议。”** |
| 1-2 | 生成依赖图（文本版） | **“根据上一步结果，帮我画出模块间依赖的文本图（谁 import 谁）。只输出依赖关系，不评价、不建议。”**                                   |
| 1-3 | 识别第三方库     | **“列出所有非标准库依赖的包名，并标出版本号（从 `requirements.txt` 里取）。不要写其他文字。”**                               |

---

## 🗂️ 第 2 阶段 — 目录与包重构

> 目标：把源码搬到 `src/` 结构并建立核心包；**此阶段不改任何函数内部逻辑**。

| #   | 任务             | 给 AI 的最小指令示例                                                                                                |
| --- | -------------- | ----------------------------------------------------------------------------------------------------------- |
| 2-1 | 生成目标目录方案       | **“基于当前功能，帮我产出一个目标目录结构示例，如 `src/core/…`、`src/utils/…` 等。只给出目录树，不写解释。”**                                     |
| 2-2 | 产生批量移动脚本       | **“为 Linux shell 生成一段 `mkdir && mv` 脚本：把现有文件移动到上一步的目录结构里；脚本里只包含命令，不附带说明。”**                                 |
| 2-3 | 更新 import 路径补丁 | **“请帮我写一个 `sed`/Python-script 补丁，把旧 import 路径批量替换为新路径，示例：`from moduleA` ➜ `from core.moduleA`。只输出脚本，不解释。”** |

---

## 🧪 第 3 阶段 — 特征测试防护网

> 目标：在 *不改业务逻辑* 的前提下，先锁定当前行为。

| #   | 任务                            | 给 AI 的最小指令示例                                                                           |
| --- | ----------------------------- | -------------------------------------------------------------------------------------- |
| 3-1 | 生成 pytest 配置                  | **“写一份最简 `pytest.ini`，设置编码 utf-8 与默认测试路径 `tests`。不要写别的内容。”**                           |
| 3-2 | 为关键函数生成 Characterization Test | **“下面粘贴函数 `foo()` 原代码。请为它生成一个 pytest 单元测试样例，只断言当前输出；不要重写函数，也不要做重构。”**                  |
| 3-3 | 创建 CI 流程草稿（可选）                | **“生成 GitHub Actions CI 配置，仅执行 `pip install -r requirements.txt && pytest`；其他步骤先不加。”** |

---

## 🛠️ 第 4 阶段 — 代码质量工具接入

> 目标：先接工具，**暂不改源码**。

| #   | 任务                     | 给 AI 的最小指令示例                                                                            |
| --- | ---------------------- | --------------------------------------------------------------------------------------- |
| 4-1 | 生成 `pyproject.toml` 基础 | **“请写一个 `pyproject.toml`，只包含 `black`、`isort`、`flake8` 的最简配置，格式正确即可，不加注释。”**             |
| 4-2 | 生成 `mypy.ini`          | **“写 `mypy.ini`，把 `strict = True` 关掉，启用 `warn_unused_ignores = True`，其余使用默认。只输出文件内容。”** |

---

## 🧩 第 5 阶段 — 渐进式小重构

> 目标：每次只动一小处，改完就跑测试。

| #   | 任务                 | 给 AI 的最小指令示例                                                                                                                               |
| --- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------ |
| 5-1 | 拆分巨大文件（示例）         | **“把 `data_processing.py` 中与报告生成无关的类 `ReportBuilder` 提取到新文件 `report/report_builder.py`。请生成 diff-patch：移动代码+更新 import；不要改类内部实现，也不要加入新逻辑。”** |
| 5-2 | 添加类型注解（示例）         | **“请在 `core/calculator.py` 的 `add()` 函数签名上添加完整的 `typing` 注解；函数体保持原样，不改变行为。”**                                                              |
| 5-3 | 替换 `print` 为日志（示例） | **“在 `utils/io_helper.py` 中，将所有 `print()` 调用替换为 `logger.info()`；若无 logger，请在文件顶部添加标准 `logging` 初始化代码。除此之外不作其他修改。”**                        |
| 5-4 | 参数配置化（示例）          | **“请把 `db_password = "hard-coded"` 改为从 `os.getenv("DB_PASSWORD")` 读取；其它配置保持现状，不改逻辑。”**                                                     |

（依业务需要继续细化：每拆一次、加注解一次、改日志一次，都写成独立任务，确保可回滚。）

---

## 🚀 第 6 阶段 — 部署与自动化

> 目标：让应用易于交付，但依然 **保持行为不变**。

| #   | 任务                          | 给 AI 的最小指令示例                                                                                                          |
| --- | --------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| 6-1 | 生成 `Dockerfile` 草稿          | **“请为一个只需 `python:3.12-slim` 运行的 CLI 程序生成最小化 `Dockerfile`，包含复制源码、安装依赖、设置入口点三步；不要写任何解释。”**                             |
| 6-2 | 编写 `docker-compose.yml`（可选） | **“基于上一步 `Dockerfile`，生成单服务的 `docker-compose.yml`，暴露端口 8000；不添加注释。”**                                                 |
| 6-3 | 生成发布脚本                      | **“写一个 bash 脚本 `build_and_push.sh`，依次执行：`docker build`、`docker tag`、`docker push` 三条命令；脚本内请留 TODO 占位符填写镜像名；不做其他说明。”** |

---

### ✅ 使用方法小贴士

1. **一次只给 AI 一个任务指令**，执行完毕并通过测试后再进行下一项。
2. 指令模板中已包含 “**只做 X 不做其它**” 约束，可按需替换文件名 / 函数名 / 目标路径。
3. 若 AI 输出 diff-patch，请人工确认并手动应用（或使用 `git apply -3`）。
4. 每完成一个任务：`git add -p && git commit -m "feat: 完成任务 X"`，保持 commit 粒度可追溯。

按照此清单，小步快跑、持续测试，就能稳健地把随意脚本重构成 **结构清晰、可测试、可维护的企业级 Python 应用**。祝重构顺利!
