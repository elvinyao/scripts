1. 你使用的主要编程语言和框架（如 Java + Spring Boot，Python + FastAPI 等）？Python + FastAPI
2. 日志是否已有中间件（如log4j、logback、winston等）统一收集？是由common里的logger module
3. 你希望梳理和改善的范围是：所有业务Bot和所有Service，还是仅ticket-service等关键模块？ 所有的bot和service
4. 是否已有异常处理机制（try-catch、全局异常处理器等），还是完全散乱分布？ 不完善，try catch很多，最好需要全局异常处理器，这个全局异常最好分为几类，主要是外部api，内部middle service api，内部专用service api。 以及其他业务上的异常


好，我将为你整理一份用于代码梳理的调查模板，帮助你检查现有所有业务Bot和Service中logger和error handling的使用情况。

模板将覆盖以下内容：

* 日志使用情况：是否统一引用common.logger模块、日志等级使用是否规范、是否包含traceId/taskId。
* 异常处理模式：是否存在try-catch、是否定义或使用统一的异常类、是否使用全局异常处理器。
* 异常类型归类建议：包括外部API异常、内部中间服务异常、内部专用服务异常、业务校验异常等。

稍后我将为你整理成结构化表格或markdown模板，便于你组织团队按模块执行调查。

Python + FastAPI 日志和异常处理现状调查模板
背景与说明
在现有系统中，各业务 Bot 和 Service 组件均使用了统一的日志模块 common.logger，并且系统日志已接入 ELK 进行集中收集和分析。为确保日志易于检索和分析，我们需要检查日志格式是否采用结构化的 JSON 格式[1]。此外，建议在日志中注入 traceId/taskId（即请求的关联 ID）来实现分布式追踪，以便串联起多个服务之间相关联的日志[2]。当前异常处理主要以散乱的 try-catch 为主，缺乏统一的全局异常处理机制，这不利于保持错误响应的一致性和隐藏实现细节。按照最佳实践，我们希望通过 FastAPI 提供的机制集中处理异常，避免在每个路由中重复处理，从而提供一致的错误响应格式[3]。未来计划引入统一的全局异常处理，将异常按来源分为四类：外部 API 异常、内部中间服务异常、内部专用服务异常和业务逻辑异常。类似地，一些项目会通过自定义异常类体系对不同来源的错误进行分类，例如定义 RemoteException（第三方服务错误）、BusinessException（业务逻辑错误）、ClientException（客户端输入错误）等，它们都继承自一个抽象基类以实现统一处理[4]。我们也需要审视各模块是否有使用统一的基础异常类来封装业务错误[5]。另外，日志级别的使用需要合理：针对可预期的业务异常或外部错误通常使用较低的级别（如 WARNING），而未预料的系统错误则应使用 ERROR 并记录堆栈[6]。以下提供的调查清单模板将帮助开发团队逐项检查每个模块/服务的日志和异常处理方式，并记录现状及存在的问题，以便后续统一和改进。
调查清单模板
请针对每个业务模块或服务，填写以下清单项（“是/否”或具体说明），以全面梳理日志和异常处理的使用情况：
模块/服务名称： （填写模块或文件名）
是否引入 common.logger 模块： （是/否）
是否有 traceId/taskId 注入： （有/无）
日志级别使用是否合理（info/warn/error）： （是/否/待改进）
日志格式是否结构化（如字典/JSON）： （是/否）
是否存在 try-catch： （是/否）
是否使用统一异常类（如自定义 BaseException 子类）： （是/否）
是否定义/使用全局异常处理器（FastAPI @exception_handler）： （是/否）
建议归类的异常类型： （列出该模块涉及的异常类别，例如 外部 API 异常 / 内部中间服务异常 / 内部专用服务异常 / 业务逻辑异常）
存在的问题或风险： （记录在日志和异常处理方面发现的不足、风险或改进建议）
以上清单可用于对照代码逐项检查。通过填写每个模块的上述条目，开发团队可以明确当前日志记录和异常处理的使用现状，并据此发现不合理之处（例如日志缺少必要的 traceId，日志级别使用不当，未使用结构化日志格式，缺少全局异常处理导致重复的 try-catch 等）。这些调查结果将为后续设计统一的日志规范和全局异常处理机制提供依据[3][5]。
参考引文：
日志结构化（JSON）有助于日志集中分析（ELK）[1]
分布式追踪需在日志中加入关联 ID（如 correlation ID）以方便跨服务排查[2]
FastAPI 支持全局异常处理，以避免每处显式 try-catch 并提供一致响应[3]
可考虑定义统一的异常基类，让自定义异常继承以实现格式统一[5]
区分异常来源并使用不同异常类，如客户端、业务、第三方异常等，有助于分类处理[4]
合理使用日志级别：预期可控的错误用 WARNING，未知故障用 ERROR 并记录堆栈[6]
